# Lexer and Parser for Python Code
## 1. Introduction
I designed a lexer and a parser to analyze and parse a subset of Python code. The lexer is responsible for tokenizing the input code, while the parser defines the grammar rules and performs syntactic analysis on the tokens generated by the lexer. 
### 1.1 Features
I aimed to design a lexer and parser for the Python syntax of the following features:
- Mathematical Expressions (Add, Subtract, Multiply, Divide, Power)
- Relational Expressions (e.g. <=, >=, <, >, ==, !=)
- Logical Expressions (and, or, not)
- Assignment Expressions (Assigning values to variables)
- String Concatenation
- Conditional Statements (if - elif - else)
- List
- Tuple
- Dictionary
- Set
- Print Statement
- Data Types: Integer, Float, Bool, String, Multiline String, None
- Identifiers

## 2. Lexer Implementation
The lexer is implemented in the [python.l](Code/python.l) file using Flex. It defines various regular expressions to match different tokens in the input code. Here are the key features and token definitions:
### 2.1 Tokens
- **MULTILINESTRING:** Matches triple-quoted multiline strings (e.g., """Hello""").
- **STRING:** Matches single or double-quoted strings (e.g., "Hello" or 'Hello').
- **EOL:** Matches newline characters.
- **INDENT:** Matches indentation consisting of either four spaces or a tab character \t
- **TRUE** and **FALSE:** Matches boolean literals.
- **NONE:** Matches the None keyword.
- **IF, ELSE,** and **ELIF:** Matches if, else, and elif keywords.
- **PRINT:** Matches the print keyword.
- **L_PARANTHESIS** and **R_PARANTHESIS:** Matches the left and right parentheses.
- **L_CURLY_BRACKET** and **R_CURLY_BRACKET:** Matches the left and right curly brackets.
- **L_SQUARE_BRACKET** and **R_SQUARE_BRACKET:** Matches the left and right square brackets.
- **COLON:** Matches the colon symbol.
- **COMMA:** Matches the comma symbol.
- **PLUS_OPR, MINUS_OPR, MULTIPLY_OPR, DIVIDE_OPR,** and **POWER_OPR:** Matches arithmetic operators for addition, subtraction, multiplication, division, and exponentiation, respectively.
- **LEQ, GEQ, EQ, NEQ, LT,** and **GT:** Matches comparison operators for less than or equal to, greater than or equal to, equal to, not equal to, less than, and greater than, respectively.
- **AND, OR,** and **NOT:** Matches logical operators for logical conjunction, logical disjunction, and logical negation, respectively.
- **IDENTIFIER:** Matches variable names.
- **INTEGER:** Matches an integer literal (positive and negative).
- **FLOAT:** Represents a floating-point literal (positive and negative).

## 3. Parser Implementation
The parser is implemented in the [python.y](Code/python.y) file using Bison. It defines the grammar rules and semantic actions to be performed for different constructs in Python code. Here are the key features and grammar rules:
### 3.1 Tokens
The tokens used in the parser are defined based on the lexer's tokens.
### 3.2 Non-Terminals
- **begin**: The starting point of the parser.
- **valid_statement**: Represents a valid statement in Python code.
- **expression**: Represents an expression in the code, including mathematical, relational, logical, assignment, and concatenation expressions.
- **if_stmt**: Represents an if statement.
- **conditional_space**: Represents the possible space (blank line, etc.) after the if statement.
- **if_elif_block**: Represents the code that comes after if and elif statements.
- **indented_block**: Represents the indented block of code.
- **else_stmt**: Represents the else statement.
- **elif_stmt**: Represents an elif statement.
- **print_stmt**: Represents a print statement.
- **expression_list**: Represents a list of expressions in the print statement.
- **data**: Represents various data types, including identifiers, integers, floats, strings, tuples, lists, sets, and dictionaries.
- **immutable**: Represents immutable data types (such as string, integer, tuple).
- **mutable**: Represents mutable data types (list, dictionary, and set).
- **LIST**: Represents a Python list.
- **TUPLE**: Represents a Python tuple.
- **SET**: Represents a Python set.
- **DICTIONARY**: Represents a Python dictionary.

### 3.3 Grammar Rules
The grammar rules are defined to handle different constructs in Python code. The semantic actions are performed when each construct is recognized. Here are the key grammar rules:
- **begin**: Starts the parser by parsing valid statements and the main program.
- **valid_statement**: Produces expressions, if statements, and print statements.
- **expression**: Handles various types of expressions, such as mathematical, relational, logical, assignment, and concatenation expressions.
- **if_stmt**: Handles if statements.
- **conditional_space**: Handles the possible space (blank line, etc.) after the if statement.
- **if_elif_block**: Handles the elif statements and else statements in the if statement.
- **indented_block**: Handles the indented block of code.
- **else_stmt**: Handles the else statement.
- **elif_stmt**: Handles the elif statement.
- **print_stmt**: Handles the print statement.
- **expression_list**: Handles a list of expressions within the print statement.
- **LIST**: Handles a Python list.
- **TUPLE**: Handles a Python tuple.
- **SET**: Handles a Python set.
- **DICTIONARY**: Handles a Python dictionary.

Certainly! Here's the updated version with the three details organized under subheadings:

## 4. Running and Testing

### 4.1 Create Executable

To create the executable for the Python lexer and parser, follow these steps:

1. Open a terminal or command prompt.
2. Navigate to the project directory using the following command:
   
   ```
   cd "path\to\project\"
   ```
4. Run the following commands in order:

   ```
   bison -d python.y -o python.c
   ```
   ```
   flex python.l
   ```
   ```
   gcc python.c -o python.exe
   ```
Or simply run the following command to create the executable:
```
cd "path\to\project\" && bison -d python.y -o python.c && flex python.l && gcc python.c -o python.exe && del python.c && del python.h && del lex.yy.c
```
  
### 4.2 Run Executable

To run the Python executable, use the following command in the terminal or command prompt:
```
.\python.exe
```
Or simply run the following command to create and run the executable:
```
cd "path\to\project\" && bison -d python.y -o python.c && flex python.l && gcc python.c -o python.exe && del python.c && del python.h && del lex.yy.c && .\python.exe
```
  
### 4.3 Test on Input from a Python File

To test the lexer and parser on input from a Python file, follow these steps:

1. Create a Python file (e.g., [`input.py`](Code/input.py)) and write your desired Python code in it.
2. Open a terminal or command prompt.
3. Type the following command to input the contents of the Python file to the lexer and parser:

   ```
   type .\input.py | .\python.exe
   ```

This will process the input code from the `input.py` file using the lexer and parser and display the results.

## 5. Conclusion
The lexer and parser I made implement a robust and accurate system for analyzing and parsing Python code. They cover various language constructs, handle edge cases, and generate appropriate tokens and parse trees.
